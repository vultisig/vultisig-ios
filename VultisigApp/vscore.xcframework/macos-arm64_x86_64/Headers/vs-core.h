/*
 * Generated by cbindgen Do not edit directly.
 */

#ifndef _VS_MLDSA_CORE_H
#define _VS_MLDSA_CORE_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

typedef enum MldsaSecurityLevel {
  MlDsa44 = 44,
  MlDsa65 = 65,
  MlDsa87 = 87,
} MldsaSecurityLevel;

enum mldsa_error
#ifdef __cplusplus
  : uintptr_t
#endif // __cplusplus
 {
  LIB_OK,
  LIB_INVALID_HANDLE,
  LIB_HANDLE_IN_USE,
  LIB_INVALID_HANDLE_TYPE,
  LIB_NULL_PTR,
  LIB_INVALID_BUFFER_SIZE,
  LIB_INVALID_SESSION_STATE,
  LIB_UNKNOWN_ERROR,
  LIB_SERIALIZATION_ERROR,
  LIB_INVALID_DERIVATION_PATH_STR,
  LIB_DERIVATION_ERROR,
  LIB_SETUP_MESSAGE_VALIDATION,
  LIB_NON_EMPTY_OUTPUT_BUFFER,
  LIB_SIGNGEN_ERROR,
  LIB_KEYGEN_ERROR,
  _LIB_QC_ERROR,
  _LIB_KEY_EXPORT_ERROR,
  LIB_INVALID_PARTY_LIST,
  _LIB_INVALID_OLD_PARTY_LIST,
  _LIB_INVALID_NEW_PARTY_LIST,
  _LIB_INVALID_PUBLIC_KEY,
  _LIB_INVALID_PRIVATE_KEY,
  LIB_REJSAMPLING,
  LIB_ABORT_PROTOCOL_PARTY_1 = 200,
};
#ifndef __cplusplus
typedef enum mldsa_error mldsa_error;
#endif // __cplusplus

typedef struct tss_buffer {
  const uint8_t *ptr;
  uintptr_t len;
} tss_buffer;

typedef struct go_slice {
  const uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} go_slice;

typedef struct Handle {
  int32_t _0;
} Handle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Free a `tss_buffer` allocated by this library.

 It is safe to pass a null pointer or an empty buffer.
 */
void tss_buffer_free(struct tss_buffer *buf);

/*
 Generate a new keygen setup message.

 # Arguments

 * `threshold` - Minimum number of parties required to sign (t).
 * `key_id` - Optional key identifier (currently the hash of the public
   key).
 * `ids` - NUL-separated party identifiers.
 * `setup_msg` - Output buffer for the encoded setup message.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_SETUP_MESSAGE_VALIDATION` - Setup message validation failed.
 */
mldsa_error mldsa_keygen_setupmsg_new(enum MldsaSecurityLevel level,
                                      uint32_t threshold,
                                      const struct go_slice *key_id,
                                      const struct go_slice *ids,
                                      struct tss_buffer *setup_msg);

/*
 Create a key generation session from an encoded setup message.

 # Arguments

 * `setup` - Encoded setup message produced by
   `mldsa_keygen_setupmsg_new*`.
 * `id` - Party identifier (must match one of the setup ids).
 * `hnd` - Output handle for the allocated session.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_SETUP_MESSAGE_VALIDATION` - Setup message validation failed.
 * `LIB_HANDLE_IN_USE` - `hnd` is not a null handle.

 */
mldsa_error mldsa_keygen_session_from_setup(enum MldsaSecurityLevel level,
                                            const struct go_slice *setup,
                                            const struct go_slice *id,
                                            struct Handle *hnd);

/*
 Apply an inbound message to a keygen session state machine.

 # Arguments

 * `session` - Keygen session handle.
 * `message` - Input message for the session.
 * `finished` - Output flag set to non-zero when the protocol finishes.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - Session mutex is poisoned.
 */
mldsa_error mldsa_keygen_session_input_message(struct Handle session,
                                               const struct go_slice *message,
                                               int32_t *finished);

/*
 Fetch the next outbound message from a keygen session.

 # Arguments

 * `session` - Keygen session handle.
 * `message` - Output buffer for the next message. Must be empty.
   If no message is available, the buffer is left empty.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `message` is null.
 * `LIB_NON_EMPTY_OUTPUT_BUFFER` - `message` is not empty.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - Session mutex is poisoned.

 */
mldsa_error mldsa_keygen_session_output_message(struct Handle session, struct tss_buffer *message);

/*
 Resolve the receiver for a message index.

 If the receiver exists, `receiver` is set to the receiver identifier.
 If the index is out of range or the message is unknown, `receiver`
 remains empty.

 # Arguments

 * `session` - session handle.
 * `message` - Message bytes previously produced by the session.
 * `index` - Receiver index to resolve.
 * `receiver` - Output buffer for the receiver identifier.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 */
mldsa_error mldsa_keygen_session_message_receiver(struct Handle session,
                                                  const struct go_slice *message,
                                                  uint32_t index,
                                                  struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `mldsa_keygen_session_free()` must be called to free the session handler.

 # Arguments

 * `session` - Key generation session handle.
 * `keyshare` - Output handle for the resulting keyshare.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `keyshare` is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - The protocol has not finished yet or
   this function was already called.
 * `LIB_ABORT_PROTOCOL_PARTY_{1..10}` - Execution was aborted by the
   designated party.
 * `LIB_KEYGEN_ERROR` - Key generation failed.

 */
mldsa_error mldsa_keygen_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate a keygen session handle and associated memory.

 # Arguments

 * `session` - Key generation session handle.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `session` is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_HANDLE_IN_USE` - The session is currently checked out.

 */
mldsa_error mldsa_keygen_session_free(struct Handle session);

/*
 Decode a keyshare from serialized bytes.

 # Arguments

 * `buf` - Serialized keyshare bytes.
 * `hnd` - Output handle for the decoded keyshare.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `buf` or `hnd` is null.
 * `LIB_SERIALIZATION_ERROR` - Failed to decode the keyshare.
 * `LIB_HANDLE_IN_USE` - `hnd` is not a null handle.
 */
mldsa_error mldsa_keyshare_from_bytes(const struct go_slice *buf, struct Handle *hnd);

/*
 Serialize a keyshare to bytes.

 # Arguments

 * `share` - Keyshare handle.
 * `buf` - Output buffer for the serialized keyshare.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `buf` is null.
 * `LIB_INVALID_HANDLE` - `share` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `share` has the wrong type.
 */
mldsa_error mldsa_keyshare_to_bytes(struct Handle share, struct tss_buffer *buf);

/*
 Extract the public key from a keyshare.

 # Arguments

 * `share` - Keyshare handle.
 * `buf` - Output buffer for the public key bytes.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `buf` is null.
 * `LIB_INVALID_HANDLE` - `share` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `share` has the wrong type.
 */
mldsa_error mldsa_keyshare_public_key(struct Handle share, struct tss_buffer *buf);

/*
 Extract the key id from a keyshare.

 # Arguments

 * `share` - Keyshare handle.
 * `buf` - Output buffer for the key id.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `buf` is null.
 * `LIB_INVALID_HANDLE` - `share` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `share` has the wrong type.
 */
mldsa_error mldsa_keyshare_key_id(struct Handle share, struct tss_buffer *buf);

/*
 Free a keyshare handle allocated by this library.

 # Arguments

 * `share` - Keyshare handle to release.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `share` is null.
 * `LIB_INVALID_HANDLE` - `share` is invalid.
 */
mldsa_error mldsa_keyshare_free(const struct Handle *share);

/*
 Extract the key id from an encoded setup message.

 # Arguments

 * `setup` - Encoded setup message.
 * `key_id` - Output buffer for the key id (empty if not present).

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `setup` or `key_id` is null.
 * `LIB_UNKNOWN_ERROR` - `setup` is malformed.
 */
mldsa_error mldsa_decode_key_id(const struct go_slice *setup, struct tss_buffer *key_id);

/*
 Extract the embedded setup message payload.

 # Arguments

 * `setup` - Encoded setup message.
 * `message` - Output buffer for the message payload (empty if not
   present).

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `setup` or `message` is null.
 * `LIB_UNKNOWN_ERROR` - `setup` is malformed.
 */
mldsa_error mldsa_decode_message(const struct go_slice *setup, struct tss_buffer *message);

/*
 Extract a party identifier by index from an encoded setup message.

 # Arguments

 * `setup` - Encoded setup message.
 * `index` - Participant index to resolve.
 * `message` - Output buffer for the party identifier (empty if the
   index is out of range).

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `setup` or `message` is null.
 * `LIB_UNKNOWN_ERROR` - `setup` is malformed.
 */
mldsa_error mldsa_decode_party_name(const struct go_slice *setup,
                                    uint32_t index,
                                    struct tss_buffer *message);

/*
 Generate a signing setup message.

 # Arguments

 * `key_id` - Key identifier (32 bytes).
 * `chain_path` - Optional derivation path (UTF-8). Defaults to `"m"`.
 * `message_hash` - Optional 32-byte message hash.
 * `ids` - NUL-separated party identifiers.
 * `setup_msg` - Output buffer for the encoded setup message.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_BUFFER_SIZE` - `key_id` or `message_hash` length is
   invalid.
 * `LIB_INVALID_DERIVATION_PATH_STR` - `chain_path` is not valid UTF-8.
 * `LIB_DERIVATION_ERROR` - Invalid derivation path.
 */
mldsa_error mldsa_sign_setupmsg_new(enum MldsaSecurityLevel level,
                                    const struct go_slice *key_id,
                                    const struct go_slice *chain_path,
                                    const struct go_slice *message_hash,
                                    const struct go_slice *ids,
                                    struct tss_buffer *setup_msg);

/*
 Create a signing session from an encoded setup message.

 If `share_or_presign` is a pre-signature handle, a finish session is
 created; otherwise a full or pre-sign session is created based on the
 setup message.

 # Arguments

 * `setup` - Encoded setup message.
 * `id` - Party identifier (must match setup ids).
 * `share_or_presign` - Keyshare or pre-signature handle.
 * `hnd` - Output handle for the allocated session.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_HANDLE` - `share_or_presign` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `share_or_presign` has the wrong type.
 * `LIB_HANDLE_IN_USE` - `share_or_presign` is checked out or `hnd` is
   not a null handle.
 * `LIB_SETUP_MESSAGE_VALIDATION` - Setup message validation failed.

 */
mldsa_error mldsa_sign_session_from_setup(enum MldsaSecurityLevel level,
                                          const struct go_slice *setup,
                                          const struct go_slice *id,
                                          struct Handle share,
                                          struct Handle *hnd);

/*
 Apply an inbound message to a signing session.

 # Arguments

 * `session` - Signing session handle.
 * `message` - Input message for the session.
 * `finished` - Output flag set to non-zero when the protocol finishes.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - Session mutex is poisoned.
 */
mldsa_error mldsa_sign_session_input_message(struct Handle session,
                                             const struct go_slice *message,
                                             int32_t *finished);

/*
 Fetch the next outbound message from a signing session.

 # Arguments

 * `session` - Signing session handle.
 * `message` - Output buffer for the next message. Must be empty.
   If no message is available, the buffer is left empty.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `message` is null.
 * `LIB_NON_EMPTY_OUTPUT_BUFFER` - `message` is not empty.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - Session mutex is poisoned.

 */
mldsa_error mldsa_sign_session_output_message(struct Handle session, struct tss_buffer *message);

/*
 Resolve the receiver for a message index.

 If the receiver exists, `receiver` is set to the receiver identifier.
 If the index is out of range or the message is unknown, `receiver`
 remains empty.

 # Arguments

 * `session` - session handle.
 * `message` - Message bytes previously produced by the session.
 * `index` - Receiver index to resolve.
 * `receiver` - Output buffer for the receiver identifier.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - A required pointer is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 */
mldsa_error mldsa_sign_session_message_receiver(struct Handle session,
                                                const struct go_slice *message,
                                                uint32_t index,
                                                struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `mldsa_keygen_session_free()` must be called to free the session handler.

 # Arguments

 * `session` - Key generation session handle.
 * `keyshare` - Output handle for the resulting keyshare.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `keyshare` is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_INVALID_SESSION_STATE` - The protocol has not finished yet or
   this function was already called.
 * `LIB_ABORT_PROTOCOL_PARTY_{1..10}` - Execution was aborted by the
   designated party.
 * `LIB_KEYGEN_ERROR` - Key generation failed.

 */
mldsa_error mldsa_sign_session_finish(struct Handle session, struct tss_buffer *output);

/*
 Deallocate a keygen session handle and associated memory.

 # Arguments

 * `session` - Key generation session handle.

 # Returns

 * `LIB_OK` on success, otherwise an error code.

 # Errors

 * `LIB_NULL_PTR` - `session` is null.
 * `LIB_INVALID_HANDLE` - `session` is invalid.
 * `LIB_INVALID_HANDLE_TYPE` - `session` has the wrong type.
 * `LIB_HANDLE_IN_USE` - The session is currently checked out.

 */
mldsa_error mldsa_sign_session_free(struct Handle session);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _VS_MLDSA_CORE_H */
