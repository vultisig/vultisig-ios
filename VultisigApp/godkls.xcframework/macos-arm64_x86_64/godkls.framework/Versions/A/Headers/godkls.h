/*
 * Generated by cbindgen Do not edit directly.
 */

#ifndef _GO_DKLS_H
#define _GO_DKLS_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

typedef enum lib_error {
  LIB_OK,
  LIB_INVALID_HANDLE,
  LIB_HANDLE_IN_USE,
  LIB_INVALID_HANDLE_TYPE,
  LIB_NULL_PTR,
  LIB_INVALID_BUFFER_SIZE,
  LIB_INVALID_SESSION_STATE,
  LIB_UNKNOWN_ERROR,
  LIB_SERIALIZATION_ERROR,
  LIB_INVALID_DERIVATION_PATH_STR,
  LIB_DERIVATION_ERROR,
  LIB_SETUP_MESSAGE_VALIDATION,
  LIB_NON_EMPTY_OUTPUT_BUFFER,
  LIB_SIGNGEN_ERROR,
  LIB_KEYGEN_ERROR,
  LIB_QC_ERROR,
  LIB_KEY_EXPORT_ERROR,
  LIB_INVALID_PARTY_LIST,
  LIB_INVALID_OLD_PARTY_LIST,
  LIB_INVALID_NEW_PARTY_LIST,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_1 = 100,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_2,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_3,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_4,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_5,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_6,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_7,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_8,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_9,
  LIB_ABORT_PROTOCOL_AND_BAN_PARTY_10,
  LIB_ABORT_PROTOCOL_PARTY_1 = 200,
  LIB_ABORT_PROTOCOL_PARTY_2,
  LIB_ABORT_PROTOCOL_PARTY_3,
  LIB_ABORT_PROTOCOL_PARTY_4,
  LIB_ABORT_PROTOCOL_PARTY_5,
  LIB_ABORT_PROTOCOL_PARTY_6,
  LIB_ABORT_PROTOCOL_PARTY_7,
  LIB_ABORT_PROTOCOL_PARTY_8,
  LIB_ABORT_PROTOCOL_PARTY_9,
  LIB_ABORT_PROTOCOL_PARTY_10,
} lib_error;

typedef struct tss_buffer {
  const uint8_t *ptr;
  uintptr_t len;
} tss_buffer;

typedef struct go_slice {
  const uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} go_slice;

typedef struct Handle {
  int32_t _0;
} Handle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void tss_buffer_free(struct tss_buffer *buf);

/*
 Generates a new DKG setup message for DKLS

 # Arguments

 * `threshold` - t parameter for the MPC threshold protocol: t minimum nodes are needed to sign. t-1 degree polynomial
 * `key_id` - unique identifier of all keyshares: currently hash of public key
 * `ids` - human readable party identifiers.
 * `setup_msg` - The returned setup msg as a tss_buffer

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.
 */
enum lib_error dkls_keygen_setupmsg_new(uint32_t threshold,
                                        const struct go_slice *key_id,
                                        const struct go_slice *ids,
                                        struct tss_buffer *setup_msg);

/*
 Creates a key generation session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error dkls_keygen_session_from_setup(const struct go_slice *setup,
                                              const struct go_slice *id,
                                              struct Handle *hnd);

/*
 Creates a key refresh session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `old_keyshare` -
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error dkls_key_refresh_session_from_setup(const struct go_slice *setup,
                                                   const struct go_slice *id,
                                                   struct Handle old_keyshare,
                                                   struct Handle *hnd);

/*
 Transition the DKLS MPC statemachine on an input message
 # Arguments

 * `session` - The session for that specific DKLS DKG protocol
 * `message` - The message to be passed as input to the state-machine of MPC Execution state machine
 * `finished` - (return) The MPC new state machine after the input message has been applied

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 */
enum lib_error dkls_keygen_session_input_message(struct Handle session,
                                                 const struct go_slice *message,
                                                 int32_t *finished);

/*
 Receive an output message.

 # Arguments

 * `session`: session handler

 * `message`: mutable reference to an empty `tss_buffer`.

 # Errors

 * `LIB_NULL_PTR`: passed `message` is null pointer

 * `LIB_NON_EMPTY_OUTPUT_BUFFER`: passed `message is not empty buffer

 */
enum lib_error dkls_keygen_session_output_message(struct Handle session,
                                                  struct tss_buffer *message);

/*
 Returns a receiver of a message.


 */
enum lib_error dkls_keygen_session_message_receiver(struct Handle session,
                                                    const struct go_slice *message,
                                                    uint32_t index,
                                                    struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `dkls_keygen_session_free()` must be called to free the session handler.

 # Arguments:

 * `session`: key generation session handler

 * `keyshare`: output keyshare handler pointer

 # Errors:

 * `LIB_NULL_PTR`: keyshare is null pointer

 * `LIB_INVALID_HANDLE`: passed invalid key generation session handler.

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_KEYGEN_ERROR`: An key generation protocol error.

 */
enum lib_error dkls_keygen_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate session handler and associated memory.

 # Arguments:

 * `session`: key generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error dkls_keygen_session_free(const struct Handle *session);

enum lib_error dkls_presign_from_bytes(const struct go_slice *buf, struct Handle *hnd);

enum lib_error dkls_presign_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error dkls_presign_session_id(struct Handle share, struct tss_buffer *buf);

/*
 Creates a key export receiver session and generate setup message for
 key exporters.

 # Arguments

 * `share` - Key share handle

 * `ids` - human readable party identifier.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error dkls_key_export_receiver_new(struct Handle share,
                                            const struct go_slice *ids,
                                            struct tss_buffer *setup_msg,
                                            struct Handle *session);

/*
 Handle input message from a key exporter.
 Flag `finished` will be set to 1 if the input message
 is last for the session.

 # Arguments

 * `session` - Key export receiver session handle

 * `message` - Buffer with an input message

 * `finished` - pointer to a finished flag

 */
enum lib_error dkls_key_export_receiver_input_message(struct Handle session,
                                                      const struct go_slice *message,
                                                      int32_t *finished);

/*
 Finish key export receiver session.

 # Arguments

 * `session` - Key export receiver session handle

 * `secret` - pointer to buffer for a exported private key

 */
enum lib_error dkls_key_export_receiver_finish(struct Handle session, struct tss_buffer *secret);

/*
 Key share export.

 Decode the setup message and encrypt share of private key for
 the key export receiver session.

 # Arguments

 * `share` - Key share handle

 * `id` - human readable identifier

 * `setup` - Setup message generate by `dkls_key_export_receiver_new()`

 * `receiver` - key export receiver session handle

 */
enum lib_error dkls_key_exporter(struct Handle share,
                                 const struct go_slice *id,
                                 const struct go_slice *setup,
                                 struct tss_buffer *message,
                                 struct tss_buffer *receiver);

/*
 Creates a key export receiver session and generate setup message for
 key exporters.

 # Arguments

 * `private_key`

 * `threshold`

 * `ids` - human readable party identifiers.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error dkls_key_import_initiator_new(const struct go_slice *private_key,
                                             uint8_t threshold,
                                             const struct go_slice *ids,
                                             struct tss_buffer *setup_msg,
                                             struct Handle *session);

enum lib_error dkls_key_importer_new(const struct go_slice *setup,
                                     const struct go_slice *id,
                                     struct Handle *session);

enum lib_error dkls_keyshare_from_bytes(const struct go_slice *buf, struct Handle *hnd);

enum lib_error dkls_keyshare_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error dkls_keyshare_public_key(struct Handle share, struct tss_buffer *buf);

enum lib_error dkls_keyshare_key_id(struct Handle share, struct tss_buffer *buf);

enum lib_error dkls_keyshare_derive_child_public_key(struct Handle share,
                                                     const struct tss_buffer *derivation_path_str,
                                                     struct tss_buffer *buf);

/*
 Can be used to generate a backup of the keyshare.
 Convert to the much smaller sized KeyshareForRefresh before serializing to bytes.
 */
enum lib_error dkls_keyshare_to_refresh_bytes(struct Handle share,
                                              struct tss_buffer *refresh_share_bytes);

enum lib_error dkls_refresh_share_from_bytes(const struct tss_buffer *buf, struct Handle *hnd);

enum lib_error dkls_refresh_share_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error dkls_keyshare_free(const struct Handle *share);

enum lib_error dkls_keyshare_chaincode(struct Handle share, struct tss_buffer *buf);

/*
 Generates a new QC setup message for DKLS.

 # Arguments

 * `keyshare` - key share handle

 * `ids` - List human readable party identifiers encoded as byte
   array with 0 byte as delimiter. This parameter defines a set of
   parties executing QC protocol.

 * `old_parties` - Array of indices of old parties. Each old party
   own a key share.

 * `new_threshold` - `T` parameter after QC.

 * `new_parties` - Array of indicies of new parties.
   It may overlap with `old_parties`.

 * `setup_msg` - Pointer to output setup message.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 * `LIB_INVALID_PARTY_LIST` - `ids` contains duplicating
   or empty party ID.

 * `LIB_INVALID_OLD_PARTY_LIST` - `old_parties` contains
   duplicating or out of range indices.

 * `LIB_INVALID_NEW_PARTY_LIST` - `new_parties` contains
   duplicating or out of range indices.

 */
enum lib_error dkls_qc_setupmsg_new(struct Handle keyshare,
                                    const struct go_slice *ids,
                                    const struct go_slice *old_parties,
                                    uint32_t new_threshold,
                                    const struct go_slice *new_parties,
                                    struct tss_buffer *setup_msg);

/*
 Creates a QC session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message

 * `id` - human readable party identifier.

 * `hnd` - A mutable reference to the handle which will store the
   allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error dkls_qc_session_from_setup(const struct go_slice *setup,
                                          const struct go_slice *id,
                                          struct Handle keyshare,
                                          struct Handle *hnd);

/*
 Transition the DKLS MPC statemachine on an input message

 # Arguments

 * `session` - The session for that specific DKLS DKG protocol

 * `message` - The message to be passed as input to the
   state-machine of MPC Execution state machine.

 * `finished` - (return) The MPC new state machine after the
   input message has been applied

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 */
enum lib_error dkls_qc_session_input_message(struct Handle session,
                                             const struct go_slice *message,
                                             int32_t *finished);

/*
 Receive an output message.

 # Arguments

 * `session`: session handler

 * `message`: mutable reference to an empty `tss_buffer`.

 # Errors

 * `LIB_NULL_PTR`: passed `message` is null pointer

 * `LIB_NON_EMPTY_OUTPUT_BUFFER`: passed `message is not empty buffer

 */
enum lib_error dkls_qc_session_output_message(struct Handle session, struct tss_buffer *message);

/*
 Returns a receiver of a message.

 */
enum lib_error dkls_qc_session_message_receiver(struct Handle session,
                                                const struct go_slice *message,
                                                uint32_t index,
                                                struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `dkls_keygen_session_free()` must be called to free the session handler.

 # Arguments:

 * `session`: key generation session handler

 * `keyshare`: output keyshare handler pointer

 # Errors:

 * `LIB_NULL_PTR`: keyshare is null pointer

 * `LIB_INVALID_HANDLE`: passed invalid key generation session handler.

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1..10}`: Execution was aborted by the
   designated party.

 * `LIB_QC_ERROR`: An key generation protocol error.

 */
enum lib_error dkls_qc_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate session handler and associated memory.

 # Arguments:

 * `session`: key generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error dkls_qc_session_free(const struct Handle *session);

/*
 Returns key_id from encoded setup message.

 # Arguments

 * `setup` - An encoded setup message.
 * `key_id` - A mutable reference to the buffer where the `key_id` will be stored.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` if `key_id` is `None`.
 * `LIB_INVALID_HANDLE` if `setup` is invalid handle.
 */
enum lib_error dkls_decode_key_id(const struct go_slice *setup, struct tss_buffer *key_id);

enum lib_error dkls_decode_session_id(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error dkls_decode_message(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error dkls_decode_party_name(const struct go_slice *setup,
                                      uint32_t index,
                                      struct tss_buffer *message);

/*
 Generate new DSG setup message.
 */
enum lib_error dkls_sign_setupmsg_new(const struct go_slice *key_id,
                                      const struct go_slice *chain_path,
                                      const struct go_slice *message_hash,
                                      const struct go_slice *ids,
                                      struct tss_buffer *setup_msg);

/*
 Generate new DSG Finish setup message.
 */
enum lib_error dkls_finish_setupmsg_new(const struct go_slice *session_id,
                                        const struct go_slice *message_hash,
                                        const struct go_slice *ids,
                                        struct tss_buffer *setup_msg);

/*
 Create a full sign session from the decoded setup message.

 # Arguments:

 * `setup`: Decoded setup message handle, which will be deallocated by
   this call.

 * `share_or_presign`: Key share or PreSign handle. Depending of type of
   passed object, the function will create a different type of session.

 * `party_sk`: Party's message signing key handle.

 * `hnd`: Output pointer to the allocated key generation session handle.

 # Errors:

 * `LIB_INVALID_HANDLE`: One or more of the passed handles is invalid.

 * `LIB_NULL_PTR`: `hnd` is a null pointer.

 * `LIB_SETUP_MESSAGE_VALIDATION`: Setup message validation failed.

 */
enum lib_error dkls_sign_session_from_setup(const struct go_slice *setup,
                                            const struct go_slice *id,
                                            struct Handle share_or_presign,
                                            struct Handle *hnd);

/*
 Process an input message
 */
enum lib_error dkls_sign_session_input_message(struct Handle session,
                                               const struct go_slice *message,
                                               uint32_t *finished);

/*
 Receive an output message.

 # Arguments

 * session: session handler

 * message: mutable reference to an empty `tss_buffer`.

 # Errors

 * LIB_NULL_PTR: passed `message` is null pointer

 * LIB_NON_EMPTY_OUTPUT_BUFFER: passed `message is not empty buffer

 */
enum lib_error dkls_sign_session_output_message(struct Handle session, struct tss_buffer *message);

/*
 Returns a receiver of a message.


 */
enum lib_error dkls_sign_session_message_receiver(struct Handle session,
                                                  const struct go_slice *message,
                                                  uint32_t index,
                                                  struct tss_buffer *receiver);

/*
 Finish the session and collect the generated value.

 For full or final sessions, this is an ECDSA signature: [ R || S || rec-id ].
 For a pre-sign session, it is the serialization of the pre-signature object.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `dkls_sign_session_free()` must be called to free the session handler.

 # Arguments

 * `session`: signature generation session handler

 * `output`: pointer to output value buffer

 # Errors:

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_AND_BAN_PARTY_{1,2,3}`: the designated party
   is corrupted.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_SIGNGEN_ERROR`: An MPC protocol error.

 */
enum lib_error dkls_sign_session_finish(struct Handle session, struct tss_buffer *output);

/*
 Deallocate session handle and associated memory.

 # Arguments:

 * `session`: signature generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error dkls_sign_session_free(const struct Handle *session);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _GO_DKLS_H */
