/*
 * Generated by cbindgen Do not edit directly.
 */

#ifndef _GO_SCHNORR_H
#define _GO_SCHNORR_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#define DEFAULT_TTL (60 * 10)

typedef enum lib_error {
  LIB_OK,
  LIB_INVALID_PUBLIC_KEY,
  LIB_INVALID_HANDLE,
  LIB_HANDLE_IN_USE,
  LIB_INVALID_HANDLE_TYPE,
  LIB_NULL_PTR,
  LIB_INVALID_BUFFER_SIZE,
  LIB_INVALID_SESSION_STATE,
  LIB_UNKNOWN_ERROR,
  LIB_SERIALIZATION_ERROR,
  LIB_INVALID_DERIVATION_PATH_STR,
  LIB_DERIVATION_ERROR,
  LIB_SETUP_MESSAGE_VALIDATION,
  LIB_NON_EMPTY_OUTPUT_BUFFER,
  LIB_SIGNGEN_ERROR,
  LIB_KEYGEN_ERROR,
  LIB_KEY_EXPORT_ERROR,
  LIB_INVALID_THRESHOLD,
  LIB_INVALID_PARTY_LIST,
  LIB_INVALID_OLD_PARTY_LIST,
  LIB_INVALID_NEW_PARTY_LIST,
  LIB_QC_ERROR,
  LIB_ABORT_PROTOCOL_PARTY_1 = 100,
  LIB_ABORT_PROTOCOL_PARTY_2,
  LIB_ABORT_PROTOCOL_PARTY_3,
  LIB_ABORT_PROTOCOL_PARTY_4,
  LIB_ABORT_PROTOCOL_PARTY_5,
  LIB_ABORT_PROTOCOL_PARTY_6,
  LIB_ABORT_PROTOCOL_PARTY_7,
  LIB_ABORT_PROTOCOL_PARTY_8,
  LIB_ABORT_PROTOCOL_PARTY_9,
  LIB_ABORT_PROTOCOL_PARTY_10,
} lib_error;

typedef struct tss_buffer {
  const uint8_t *ptr;
  uintptr_t len;
} tss_buffer;

typedef struct go_slice {
  const uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} go_slice;

typedef struct Handle {
  int32_t _0;
} Handle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void tss_buffer_free(struct tss_buffer *buf);

/*
 Generates a new DKG setup message for Schnorr MPC protocol

 # Arguments

 * `threshold` - t parameter for the MPC threshold protocol: t minimum nodes are needed to sign. t-1 degree polynomial
 * `key_id` - unique identifier of all keyshares: currently hash of public key
 * `ids` - human readable party identifiers.
 * `setup_msg` - The returned setup msg as a tss_buffer

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.
 */
enum lib_error schnorr_keygen_setupmsg_new(uint32_t threshold,
                                           const struct go_slice *key_id,
                                           const struct go_slice *ids,
                                           struct tss_buffer *setup_msg);

/*
 Creates a key generation session from an encoded setup message for Schnorr

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_keygen_session_from_setup(const struct go_slice *setup,
                                                 const struct go_slice *id,
                                                 struct Handle *hnd);

/*
 Creates a key refresh session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message
 * `id` - human readable party identifier.
 * `old_keyshare` -
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_key_refresh_session_from_setup(const struct go_slice *setup,
                                                      const struct go_slice *id,
                                                      struct Handle old_keyshare,
                                                      struct Handle *hnd);

/*
 Creates a migration session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message. Same as keygen setup msg
 * `id` - human readable party identifier.
 * `public_key` - the expected public key from GG20
 * `root_chain_code` - the root chain code from GG20
 * `secret_coefficient` - the secret coefficient we need to hardcode as s_i_0 at keyrefresh object
 * `hnd` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_key_migration_session_from_setup(const struct go_slice *setup,
                                                        const struct go_slice *id,
                                                        const struct go_slice *public_key,
                                                        const struct go_slice *root_chain_code,
                                                        const struct go_slice *secret_coefficient,
                                                        struct Handle *hnd);

/*
 Transition the Schnorr MPC statemachine on an input message
 # Arguments

 * `session` - The session handler for that specific Schnorr DKG protocol
 * `message` - The message to be passed as input to the statemaching of MPC Execution state machine
 * `finished` - (return) The MPC new state machine after the input message has been applied

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.
 */
enum lib_error schnorr_keygen_session_input_message(struct Handle session,
                                                    const struct go_slice *message,
                                                    int32_t *finished);

/*
 Receive an output message for the Schnorr MPC statemachine

 # Arguments

 * `session`: session handler

 * `message`: mutable reference to an empty `tss_buffer`.

 # Errors

 * `LIB_NULL_PTR`: passed `message` is null pointer

 * `LIB_NON_EMPTY_OUTPUT_BUFFER`: passed `message is not empty buffer

 */
enum lib_error schnorr_keygen_session_output_message(struct Handle session,
                                                     struct tss_buffer *message);

/*
 Returns a receiver of a message. Tailored for Vultisig
 */
enum lib_error schnorr_keygen_session_message_receiver(struct Handle session,
                                                       const struct go_slice *message,
                                                       uint32_t index,
                                                       struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share for Schnorr.
 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `schnorr_keygen_session_free()` must be called to free the session handler.

 # Arguments:

 * `session`: key generation session handler

 * `keyshare`: output keyshare handler pointer

 # Errors:

 * `LIB_NULL_PTR`: keyshare is null pointer

 * `LIB_INVALID_HANDLE`: passed invalid key generation session handler.

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_KEYGEN_ERROR`: An key generation protocol error.

 */
enum lib_error schnorr_keygen_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate session handler and associated memory.

 # Arguments:

 * `session`: key generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error schnorr_keygen_session_free(const struct Handle *session);

/*
 Generates a new QC setup message.

 # Arguments

 * `keyshare` - key share handle

 * `ids` - List human readable party identifiers encoded as byte
   array with 0 byte as delimiter. This parameter defines a set of
   parties executing QC protocol.

 * `old_parties` - Array of indices of old parties. Each old party
   own a key share.

 * `new_threshold` - `T` parameter after QC.

 * `new_parties` - Array of indicies of new parties.
   It may overlap with `old_parties`.

 * `setup_msg` - Pointer to output setup message.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 * `LIB_INVALID_PARTY_LIST` - `ids` contains duplicating
   or empty party ID.

 * `LIB_INVALID_OLD_PARTY_LIST` - `old_parties` contains
   duplicating or out of range indices.

 * `LIB_INVALID_NEW_PARTY_LIST` - `new_parties` contains
   duplicating or out of range indices.

 */
enum lib_error schnorr_qc_setupmsg_new(struct Handle keyshare,
                                       const struct go_slice *ids,
                                       const struct go_slice *old_parties,
                                       uint32_t new_threshold,
                                       const struct go_slice *new_parties,
                                       struct tss_buffer *setup_msg);

/*
 Creates a QC session from a encoded setup message.

 # Arguments

 * `setup` - A reference of encoded setup message

 * `id` - human readable party identifier.

 * `hnd` - A mutable reference to the handle which will store the
   allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 * `LIB_SETUP_MESSAGE_VALIDATION` - if setup message validation failed.

 */
enum lib_error schnorr_qc_session_from_setup(const struct go_slice *setup,
                                             const struct go_slice *id,
                                             struct Handle keyshare,
                                             struct Handle *hnd);

/*
 Transition the MPC statemachine on an input message

 # Arguments

 * `session` - The session for that specific DKLS DKG protocol

 * `message` - The message to be passed as input to the
   state-machine of MPC Execution state machine.

 * `finished` - (return) The MPC new state machine after the
   input message has been applied

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - if one of passed pointers is NULL.

 */
enum lib_error schnorr_qc_session_input_message(struct Handle session,
                                                const struct go_slice *message,
                                                int32_t *finished);

/*
 Receive an output message.

 # Arguments

 * `session`: session handler

 * `message`: mutable reference to an empty `tss_buffer`.

 # Errors

 * `LIB_NULL_PTR`: passed `message` is null pointer

 * `LIB_NON_EMPTY_OUTPUT_BUFFER`: passed `message is not empty buffer

 */
enum lib_error schnorr_qc_session_output_message(struct Handle session, struct tss_buffer *message);

/*
 Returns a receiver of a message.

 */
enum lib_error schnorr_qc_session_message_receiver(struct Handle session,
                                                   const struct go_slice *message,
                                                   uint32_t index,
                                                   struct tss_buffer *receiver);

/*
 Finish the session and collect the generated key share.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `dkls_keygen_session_free()` must be called to free the session handler.

 # Arguments:

 * `session`: key generation session handler

 * `keyshare`: output keyshare handler pointer

 # Errors:

 * `LIB_NULL_PTR`: keyshare is null pointer

 * `LIB_INVALID_HANDLE`: passed invalid key generation session handler.

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1..10}`: Execution was aborted by the
   designated party.

 * `LIB_QC_ERROR`: An key generation protocol error.

 */
enum lib_error schnorr_qc_session_finish(struct Handle session, struct Handle *keyshare);

/*
 Deallocate session handler and associated memory.

 # Arguments:

 * `session`: key generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error schnorr_qc_session_free(const struct Handle *session);

enum lib_error schnorr_keyshare_from_bytes(const struct go_slice *buf, struct Handle *hnd);

enum lib_error schnorr_keyshare_to_bytes(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_public_key(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_key_id(struct Handle share, struct tss_buffer *buf);

enum lib_error schnorr_keyshare_chaincode(struct Handle share, struct tss_buffer *buf);

/*
 Returns key_id from encoded setup message.

 # Arguments

 * `setup` - An encoded setup message.
 * `key_id` - A mutable reference to the buffer where the `key_id` will be stored.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` if `key_id` is `None`.
 * `LIB_INVALID_HANDLE` if `setup` is invalid handle.
 */
enum lib_error schnorr_decode_key_id(const struct go_slice *setup, struct tss_buffer *key_id);

enum lib_error schnorr_decode_session_id(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error schnorr_decode_message(const struct go_slice *setup, struct tss_buffer *message);

enum lib_error schnorr_decode_party_name(const struct go_slice *setup,
                                         uint32_t index,
                                         struct tss_buffer *message);

/*
 Generate new DSG setup message.
 */
enum lib_error schnorr_sign_setupmsg_new(const struct go_slice *key_id,
                                         const struct go_slice *chain_path,
                                         const struct go_slice *message,
                                         const struct go_slice *ids,
                                         struct tss_buffer *setup_msg);

/*
 Create a full sign session from the decoded setup message.

 # Arguments:

 * `setup`: Decoded setup message handle, which will be deallocated by
   this call.

 * `id`: The identifier of a signer.

 * `share_or_presign`: Key share or PreSign handle. Depending of type of
   passed object, the function will create a different type of session.

 * `hnd`: Output pointer to the allocated key generation session handle.

 # Errors:

 * `LIB_INVALID_HANDLE`: One or more of the passed handles is invalid.

 * `LIB_NULL_PTR`: `hnd` is a null pointer.

 * `LIB_SETUP_MESSAGE_VALIDATION`: Setup message validation failed.

 */
enum lib_error schnorr_sign_session_from_setup(const struct go_slice *setup,
                                               const struct go_slice *id,
                                               struct Handle share,
                                               struct Handle *hnd);

/*
 Process an input message
 */
enum lib_error schnorr_sign_session_input_message(struct Handle session,
                                                  const struct go_slice *message,
                                                  uint32_t *finished);

/*
 Receive an output message.

 # Arguments

 * session: session handler

 * message: mutable reference to an empty `tss_buffer`.

 # Errors

 * LIB_NULL_PTR: passed `message` is null pointer

 * LIB_NON_EMPTY_OUTPUT_BUFFER: passed `message is not empty buffer

 */
enum lib_error schnorr_sign_session_output_message(struct Handle session,
                                                   struct tss_buffer *message);

/*
 Returns a receiver of a message.
 */
enum lib_error schnorr_sign_session_message_receiver(struct Handle session,
                                                     const struct go_slice *message,
                                                     uint32_t index,
                                                     struct tss_buffer *receiver);

/*
 Finish the session and collect the generated value.

 For full or final sessions, this is an EdDSA signature: [ R || S ].
 For a pre-sign session, it is the serialization of the pre-signature object.

 The session will be unconditionally finished, and all inner memory
 will be released. An error code, if any, will be returned on the first
 call. Subsequent calls will return `LIB_INVALID_SESSION_STATE`.

 `schnorr_sign_session_free()` must be called to free the session handler.

 # Arguments

 * `session`: signature generation session handler

 * `output`: pointer to output value buffer

 # Errors:

 * `LIB_INVALID_SESSION_STATE`: The protocol execution is not finished
   yet, or the function was called more than once.

 * `LIB_ABORT_PROTOCOL_PARTY_{1,2,3}`: Execution was aborted by the
   designated party.

 * `LIB_SIGNGEN_ERROR`: An MPC protocol error.

 */
enum lib_error schnorr_sign_session_finish(struct Handle session, struct tss_buffer *output);

/*
 Deallocate session handle and associated memory.

 # Arguments:

 * `session`: signature generation session handle

 # Errors:

 * `LIB_NULL_PTR`: passed null pointer

 * `LIB_INVALID_HANDLE`: passed an invalid session handle

 */
enum lib_error schnorr_sign_session_free(const struct Handle *session);

/*
 Creates a key export receiver session and generate setup message for
 key exporters.

 # Arguments

 * `share` - Key share handle

 * `ids` - human readable party identifier.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error schnorr_key_export_receiver_new(struct Handle share,
                                               const struct go_slice *ids,
                                               struct tss_buffer *setup_msg,
                                               struct Handle *session);

/*
 Handle input message from a key exporter.
 Flag `finished` will be set to 1 if the input message
 is last for the session.

 # Arguments

 * `session` - Key export receiver session handle

 * `message` - Buffer with an input message

 * `finished` - pointer to a finished flag

 */
enum lib_error schnorr_key_export_receiver_input_message(struct Handle session,
                                                         const struct go_slice *message,
                                                         int32_t *finished);

/*
 Finish key export receiver session.

 # Arguments

 * `session` - Key export receiver session handle

 * `secret` - pointer to buffer for a exported private key

 */
enum lib_error schnorr_key_export_receiver_finish(struct Handle session, struct tss_buffer *secret);

/*
 Key share export.

 Decode the setup message and encrypt share of private key for
 the key export receiver session.

 # Arguments

 * `share` - Key share handle

 * `id` - human readable identifier

 * `setup` - Setup message generated by `schnorr_key_export_receiver_new()`

 * `message` - encrypted message

 * `receiver` - key export receiver session handle

 */
enum lib_error schnorr_key_exporter(struct Handle share,
                                    const struct go_slice *id,
                                    const struct go_slice *setup,
                                    struct tss_buffer *message,
                                    struct tss_buffer *receiver);

/*
 Creates a key import receiver session and generate setup message for
 key importers.

 # Arguments

 * `private_key`

 * `threshold`

 * `ids` - human readable party identifiers.

 * `setup_msg` - Buffer for the setup message

 * `session` - A mutable reference to the handle which will store the allocated session.

 # Returns

 * A `lib_error` indicating success or type of error.

 # Errors

 * `LIB_NULL_PTR` - passed a null pointer

 */
enum lib_error schnorr_key_import_initiator_new(const struct go_slice *private_key,
                                                uint8_t threshold,
                                                const struct go_slice *ids,
                                                struct tss_buffer *setup_msg,
                                                struct Handle *session);

enum lib_error schnorr_key_importer_new(const struct go_slice *setup,
                                        const struct go_slice *id,
                                        struct Handle *session);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _GO_SCHNORR_H */
